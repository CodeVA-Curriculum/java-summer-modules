---
title: Digital Representations of Information
author: Jon Stapleton
date: 4/6/2022
type: page
---

<!-- ::youtube[A video explaining how binary represents digital information]{#oXmKJ_tYg34} -->

# Digital Representations of Information

This page explains the basics of binary information: what it is, why it's so important, and what computers use it for.

## What is Binary?

Binary is a number system where all values (all quantities) are expressed using a combination of `1`s and `0`s. You can think of binary as being a sort of language that computers speak. Binary numbers are the fundamental unit of data in computing; everything that goes on in a computer is expressed in binary. Here's some binary data:

```diff
01001000 01100101 01101100 01101100 01101111 00100001
```

You can translate it by copying and pasting the text into a "binary translator", like [this one](https://toolnanny.com/convert-binary-to-unicode). Check out what it says! There's a lot more going on here than what meets the eye, though; we'll unpack how this all works throughout the module.

## Digital Communication with Binary

To understand why we use binary for digital information, it's helpful to understand how digital devices communicate with one another.

Imagine that all digital devices communicate using a wire that conducts electricty (the situation is a lot more complex than this in reality, but suspend your disbelief for a moment). The easiest way to visualize this process is to imagine a keyboard connected to a computer. When someone presses a key on the keyboard, the keyboard needs to send information about the key to the computer so the computer can respond to the user input. The keyboard will accomplish this task by manipulating the voltage to send a string of binary data over the USB cable:

<!-- binary-voltage.jpg -->
![A graph of voltage, with high and low regions labeled with ones and zeroes respectively. A USB cable is parallel to the graph, implying that the voltage on the graph is representing what goes on inside the cable.](66767304)

All digital communication works this same way, more or less. Computers send one another binary data in the form of electrical signals, and then react to that data somehow. *All* information in a computer is binary, eventually, from the instructions that control the computer's behavior to the data stored on its hard drive. Computers use a electronic component called a **transistor** to "store" these high and low voltages in a circuit, allowing the computer to recall that digital information for later.

<!-- transistors.jpg -->
![A grid of squares, with white and black tokens in them representing transistors with low and high voltage values stored in them.](66767309)

This fundamental *physical* reality of computing devices--the fact that they use high and low voltages, and store information using transistors--is the reason computer scientists use binary when they try to represent digital information in writing. The binary "base-2" **number system** matches the computing device, the same way our normal "base-10" system (where we count from `0` to `9`, and then start on the next place value with `10`) matches our human hands.

## Binary & You

The reason you probably don't see too much binary when you *use* a computer is that binary is pretty difficult for humans to read. Despite the fact that computers can interpret binary data *incredibly* quickly, it's not that great of a system for expressing information to other *humans*. In order for humans and computers to communicate with one another, we need to be able to convert digital information into "human-readable" information and back again. The process of converting information from one format to another is called **encoding**, and converting it back again is called **decoding**. Here's how that works.

### Binary to Decimal

Binary numbers are just that: numbers, representing a quantity. Binary numbers use a "base 2" number system to express quantity. Base 2 systems are a lot different than the base-10 "decimal" system you are used to.

In a base-2 system, the first place value can be either `1` or `0` (you can read 1-digit binary numbers like you would decimal numbers). The next place value represents `2`, so to express the number `2` in binary, you would write `10` (this number *looks* like the number ten, but it isn't). The next place value represents `4`, so to express the number `4` in binary you would write `100`. Each `1` or `0` in a binary number is called a *bit* (short for "binary digit"). 

You might notice that writing binary can be a little confusing, especially when the number only has a couple of bits. Is `110` supposed to say "one-hundred and ten", or "six"? To help with this confusion, the Praxis test uses subscript to denote the base system you should interpret a given number within. If the test needs to display "one hundred and ten" in decimal, it will look like this: <code>110<sub>10<sub></code>, where the subscript denotes "base-10". If the test wants to display "six" in binary, it would look like this: <code>110<sub>2</sub></code>, where the subscript denotes "base-2". We'll use that notation throughout this module from now on.

Here's a table which shows the place values for binary numbers up to 8 bits long:

| Binary Version | Exponent Version | Decimal Version |
| ---------- | ------------- | ------- |
| `00000001`<sub>2</sub> | 2<sup>0</sup> | 1<sub>10</sub>   |
| `00000010`<sub>2</sub> | 2<sup>1</sup> | 2<sub>10</sub>   |
| `00000100`<sub>2</sub> | 2<sup>2</sup> | 4<sub>10</sub>   |
| `00001000`<sub>2</sub> | 2<sup>3</sup> | 8<sub>10</sub>   |
| `00010000`<sub>2</sub> | 2<sup>4</sup> | 16<sub>10</sub>  |
| `00100000`<sub>2</sub> | 2<sup>5</sup> | 32<sub>10</sub>  |
| `01000000`<sub>2</sub> | 2<sup>6</sup> | 64<sub>10</sub>  |
| `10000000`<sub>2</sub> | 2<sup>7</sup> | 128<sub>10</sub> |

You can figure out the value of a binary number by summing the place values for the "on" bits (i.e., the place values with `1` instead of `0`).

<!-- binary-arithmetic.jpg -->
![A handrawn diagram showing how to sum the place values for the binary number 1011 to convert it to its decimal value, 11 (8+0+2+1)](66767303)

> **Practice:** Try to figure out which binary number is *larger* in the pairs below. After you've made your choices, click the "Reveal Solution" button to see how you did.

| Option 1           | Option 2           |
| ------------------ | ------------------ |
| `0001`<sub>2</sub> | `0010`<sub>2</sub> |
| `1101`<sub>2</sub> | `1100`<sub>2</sub> |
| `0110`<sub>2</sub> | `1001`<sub>2</sub> |
| `0111`<sub>2</sub> | `1111`<sub>2</sub> |
| `0100`<sub>2</sub> | `0010`<sub>2</sub> |

:::collapse{title="Reveal Solution"}
| Option 1               | Option 2               |
| ---------------------- | ---------------------- |
|   `0001`<sub>2</sub>   | ✨`0010`<sub>2</sub>✨ |
| ✨`1101`<sub>2</sub>✨ |   `1100`<sub>2</sub>   |
|   `0110`<sub>2</sub>   | ✨`1001`<sub>2</sub>✨ |
|   `0111`<sub>2</sub>   | ✨`1111`<sub>2</sub>✨ |
| ✨`0100`<sub>2</sub>✨ |   `0010`<sub>2</sub>   |
:::

### Binary & Hexadecimal

Computers and programmers who deal with such things often group binary information into standardized "chunks" with different names. Each type of "chunk" stores a different amount of data. A *bit* is one example: it is a "chunk" of data that only contains two possible values, `0` and `1`. A *byte* is a chunk of information 8 bits long, meaning that a "byte" can represent any number between `0` and `255`. You might be more familiar with the names for larger chunks of data: a *gigabyte* is a chunk of binary data 8,000,000,000 bits long.

**Bytes** are a very common unit of data in computing but they are very difficult to read and interpret quickly, even with practice. To solve this problem, computer engineers started using another number system to represent them: *hexadecimal*. While binary is a "base-2" number system (where each place value represents one of two possible values), hexadecimal is a "base-16" number system, where each place value contains one of *sixteen* possible values, notated as a value between `0` (the lowest value, representing `0`) and `F` (the highest value, representing `15`). Because one hexadecimal digit can represent 16 possible values, it can take the place of four bits (called a "nibble" or "nybble"). Usually, you'll see hexadecimal numbers in pairs, used to represent a *byte* of data (eight bits), like `0F`<sub>16</sub>. Notice that I've written the hexadecimal number with a subscript "16", denoting the notation as a hexadecimal (base-16) number.

Check out the table below to see some numbers written using decimal, binary, and hexadecimal number systems:

| Decimal | Binary     | Hexadecimal |
| ------- | ---------- | ----------- |
| `0`<sub>10</sub>     | `00000000`<sub>2</sub> | `00`<sub>16</sub>        |
| `7`<sub>10</sub>     | `00000111`<sub>2</sub> | `07`<sub>16</sub>        |
| `15`<sub>10</sub>    | `00001111`<sub>2</sub> | `0F`<sub>16</sub>        |
| `16`<sub>10</sub>    | `00010000`<sub>2</sub> | `10`<sub>16</sub>        |
| `113`<sub>10</sub>   | `01110001`<sub>2</sub> | `71`<sub>16</sub>        |
| `255`<sub>10</sub>   | `11111111`<sub>2</sub> | `FF`<sub>16</sub>        |

Hexadecimal numbers are a little bit easier to read than binary numbers are (though that's a pretty low bar to clear), especially with practice. They are a lot more compact than binary numbers, and you aren't at risk of miscounting or shuffling the `0`s and `1`s when you read them.

> **Practice:** Try to figure out which hexadecimal number is *larger* in the pairs below. After you've made your choices, click the "Reveal Solution" button to see how you did.

| Option 1          | Option 2          |
| ----------------- | ----------------- |
| `FE`<sub>16</sub> | `FF`<sub>16</sub> |
| `30`<sub>16</sub> | `03`<sub>16</sub> |
| `A9`<sub>16</sub> | `AC`<sub>16</sub> |
| `FA`<sub>16</sub> | `F9`<sub>16</sub> |
| `0C`<sub>16</sub> | `02`<sub>16</sub> |

:::collapse{title="Reveal Solution"}
| Option 1              | Option 2              |
| --------------------- | --------------------- |
|   `FE`<sub>16</sub>   | ✨`FF`<sub>16</sub>✨ |
| ✨`30`<sub>16</sub>✨ |   `03`<sub>16</sub>   |
|   `A9`<sub>16</sub>   | ✨`AC`<sub>16</sub>✨ |
| ✨`FA`<sub>16</sub>✨ |   `F9`<sub>16</sub>   |
| ✨`0C`<sub>16</sub>✨ | ✨`02`<sub>16</sub>✨ |
:::

## Information Representations on the Praxis Exam

You'll be expected to perform the following number system-related skills on the *Computer Science Praxis Exam*:

* Identifying binary, hexadecimal, and decimal values
* Converting between binary, hexadecimal, and decimal representations
* Comparing binary and hexadecimal values
* Performing arithmetic with binary numbers

The following pages will help you practice these skills.