---
title: The Processing Animation Loop
authors: Jon Stapleton & Eva Anderson
date: 4/12/2022
type: page
---

::youtube[A video tutorial covering the Processing animation loop]{#oXmKJ_tYg34}

# The Processing Animation Loop

So far, you've written Java programs that the computer executes *sequentially*, meaning that the computer "reads" each command one at a time, and performs each task in the order you've written it. That is, for the most part; you've also written some *looping* code using `while` loops. We will be building on this "looping" concept in this module as we discuss Processing's *animation loop*.

## Animation Loops Explained

Most programs that display moving images (think video games or other interactive visual applications) have a structure comprised of two sections: one section for code that should run at the *beginning* of the program (i.e., right when you press "play"), and code that should loop over and over again *while the program is open*. This looping design pattern is called an *animation loop*.

Here's a sneak peek at what an animation loop looks like in the Processing environment. This program displays a circle "floating" across the screen from left to right:

:::code-example{src="TODO:}
```java
// declare variables
float x = 10; // a variable to keep track of circle's position

// code to run right away, once
void setup() {
  size(800, 600);
}

// code to loop over and over again, forever
void draw() {
  background(255);
  circle(x, 300, 20);
  x = x + 0.5;
}
```
:::

This section of code contains some new patterns, and you may find it difficult to trace the program as written. To help explain what's going on, read the code below; it's the same as the code above, but written using programming patterns you've already seen. The code doesn't work as it should, but I'm going to start with this example as a way to explain how to read the animation loop example.

```java
// variable declarations
float x = 10; // a variable to keep track of circle's position

// code to run right away
size(800, 600);

// code to run in a loop
while(true) { // loop forever
    circle(x, 300, 20);
    x = x + 0.5; // update the `x` variable
}
```

This code example is divided into three sections: a section for **variable declarations**, a section for **code to run right away**, and a section for **code that loops while the program is running**. The interesting part is in the `while` loop; here's what the code would look like if I wrote the loop out by hand:

```java
circle(x 300, 20); // x is 10
x = x + 0.5; // increase x variable

circle(x 300, 20); // x is 10.5
x = x + 0.5; // increase x variable

circle(x 300, 20); // x is 11
x = x + 0.5; // increase x variable

// etc...
```

Each time the computer loops back around to the top of the loop, the variable called `x` has a different value--the program has increased the value of the `x` variable by `0.5`. Thus, the circle should appear in a different place each time the computer executes the `circle(x, 300, 20);` command.

You can try running the example with the `while` loop in Processing if you'd like; you'll get output, and you'll notice the circle sort of "smears" across the screen. However, the `while` loop will never end, and computer will try to execute the code as fast as possible. This situation leads to all sorts of problems.

## Processing's Animation Methods

The Processing environment has a built-in coding pattern designed to help solve this problem: the `setup()` and `draw()` methods. These methods are unlike the other ones you've created so far; here's how to use them:

### Step 1: Declare Your Variables

First, declare your variables at the top of your program, like so:

```java
float x = 10;
```

Same as usual.

### Step 2: Define the `setup()` Process

The next step is to add the `setup()` section to your code. Start by creating an empty `setup()` section like this:

```java
float x = 10;

// setup section
void setup() {

}
```

Then, add the code that you'd like the computer to run at the *beginning* of the program between the `{` and the `}` next to `setup()` (in most cases, this will be the `size()` method, though you can add whatever you want in addition to that):

```java
float x = 10;

// setup section
void setup() {
    size(800,600);
}
```

The computer will execute the code inside the `setup()` section *once* as soon as you press the "play" button.

### Step 3: Define the `draw()` Loop

Finally, add the code you'd like the computer to loop during the program's runtime to the `draw()` section. Same as the `setup()` process, start with an empty `draw()` section:

```java
float x = 10;

// setup section
void setup() {
    size(800,600);
}

// looping section
void draw() {

}
```

...then, add the code. I've copied the code directly from the inside of the `while` loop from the example above:

:::code-example{src="TODO:"}
```java
float x = 10;

// setup section
void setup() {
    size(800,600);
}

// looping section
void draw() {
    circle(x, 300, 20);
    x = x + 0.5;
}
```
:::

Go ahead and try out the code! You'll notice that the circle sort of "smears" across the screen (smoothly this time!). To prevent this from happening, you can apply a `background()` before the `circle()` to "cover up" the old circles:

:::code-example{src="TODO:"}
```java
float x = 10;

// setup section
void setup() {
    size(800,600);
}

// looping section
void draw() {
    background(255); // draw a white background
    circle(x, 300, 20);
    x = x + 0.5;
}
```
:::

Now you've arrived at the first example! You should read this code exactly like you would read the `while` loop example; the only difference is that instead of using a `while` loop, Processing expects us to use the `draw()` section instead.

## How Processing Interprets This Code

The "sections" I've explained above, `setup()` and `draw()`, are methods just like `circle()` and `fill()`. The reason you need to write them so differently in this situation is that these methods are ones that you need to *define*, rather than methods you need to *call*.

Recall from the very first module that a method like `circle()` or `color()` causes the computer to trigger a process, like outputting information to the screen to show a shape or calcuating a number to represent a color. The Processing framework has defined these methods for you, so you can just call the method instead of having to write code that manipulates the screen directly. This is sort of similar to how a car works, in a way--instead of having to inject fuel into the motor yourself, the car has a built-in pedal that takes care of that for you; all you have to do is press it. In the same way, you don't have to know how to write code that controls the screen or creates an application window; all you have to do is call the Processing methods that do that for you.

The function definitions for the methods you are familiar with are hidden in the Processing framework, like a car engine is hidden under the hood. However, the `setup()` and `draw()` methods are different; Processing doesn't have definitions for those methods. Instead, *you* need to define them. Then, Processing executes the code in those method definitions (that's what the above pattern is called) when you start up the program in a very specific way:

```java
setup();

while(true) {
    draw();
}
```

*Note: This is not functional code! It is just an explanation of how Processing calls the `setup()` and `draw()` methods "under the hood" after you press "play".*

## Variable Scope

Now that you know how the `setup()` and `draw()` methods work, you might be wondering why *all* the code isn't in either of those two method definitions. Why are the variable declarations at the top?

The answer is this: if you declare a variable inside the `setup()` or `draw()` definitions, it will only be accessible *inside that method*, and the computer will *discard it after the method finishes running*. You can try this for yourself; the following code will produce an error:

```java
void setup() {
    float x = 10;
    size(800,600);
}
void draw() {
    background(255);
    circle(x, 300, 20);
    x = x + 0.5;
}
```

...because the way it's written above, the `x` variable is only available inside the `setup()` method definition. This feature is called "scope"; variables can have *global* scope (meaning they are available across the whole program), or *local* scope (meaning they are available only in a specific section of the code). 

In the example above, the code initializes the variable called `x` inside the `setup()` method definition, meaning it is a *local* variable scoped to the `setup()` method. When the computer executes the `setup()` method it keeps the `x` variable in memory until the end of the method definition. Then, the computer discards the variable `x` and the value stored within it, deleting it from memory. Because the computer discards local variables when it exits the variable's scope (in this example, the `setup()` method), the computer encounters an error when it tries to use the `x` variable in the `draw()` method. The computer already discarded the local `x` from the `setup()` method, which means the `x` in `draw()` is *undefined*.

![Diagram showing the difference between how the computer manages local and global variables in memory](TODO:)

Declaring variables in the `draw()` scope works the same way. Even though the computer calls `draw()` many times, it will discard any variables initialized in the `draw()` scope each time it finishes running the method. The only way to make sure variables stay in memory throughout the program (and to ensure that the variable is available to all the methods in the program) is to declare it *globally* at the top of your program, before the `setup()` method.

Scope can be somewhat confusing, and can create errors that are difficult to resolve. For now, you should pretty much always declare your variables at the top of your program *before* the `setup()` method. That way, your variables will have *global* scope and you won't run into any frustrating errors:

```java
// declare variables
float x = 10;

// setup
void setup() {
    size(800, 600);
}

// loop
void draw() {
    background(255);
    circle(x, 300, 20);
    x = x + 0.5;
}
```

That said, you might find it useful to use *local* variables sometimes, especially if you want to create a variable but you don't need it to keep its value across method calls:

```java
[TODO:]
```

As you get better at coding, you'll probably use local variables more and more. There's nothing wrong with using global variables, but in very large or complex programs which have dozens of variables, it can be difficult to keep track of them.

> **Practice:** Try adding another variable and another "floating" shape to the example above! Be sure to declare your variable at the top of the code, and to add the code that displays the shape and updates your new variable to the `draw()` method definition.